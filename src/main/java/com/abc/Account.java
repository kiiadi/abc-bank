package com.abc;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import com.abc.BankConstants.AccountType;
import com.abc.BankConstants.TransactionType;

public class Account {
	// Account should have unique id of customer rather than name
	// but for sample program I am assuming that there will be only 
	// one customer for the given name. that is for sample program only.
	// in real world , customer and account both will have id and that will 
	// be generated by number fountain.
	private String customerName;
	private final AccountType accountType;
	public List<Transaction> transactions;
	private InterestCalculator interestCalculator; 
	public double amount;
		public Account(AccountType accountType) {
		this.accountType = accountType;
		this.transactions = new ArrayList<Transaction>();
		interestCalculator = InterestCalculatorFactory.getInterestCalculator(accountType);
		amount = 0d;
	}

	public void deposit(double amount) {
		if (amount <= 0) {
			throw new IllegalArgumentException(
					"amount must be greater than zero");
		} else {
			this.amount += amount;
			transactions.add(new Transaction(TransactionType.DEPOSIT, amount));
		}
	}

	public void withdraw(double amount) {
		if (amount <= 0) {
			throw new IllegalArgumentException(
					"amount must be greater than zero");
		} else if (this.amount < amount) {
			throw new IllegalArgumentException("Insufficient fund.");
		} else {
			this.amount -= amount;
			transactions
					.add(new Transaction(TransactionType.WITHDRAWAL, amount));
		}
	}
	// This function is not fully implemented yet 
	// it needs a way to check if interest is already calculated today
	// if it does , it should ignore the request of calculation
	// also if days difference are more in that case we might need to go 
	// reverse in transaction list to calculate interest.
	// but that can be leave for later
	public void applyInterest() {
			double interest = interestCalculator.calculate(this);
			this.amount += interest;
			transactions
					.add(new Transaction(TransactionType.INTEREST, interest));
	}

	public double interestEarned() {
		double interest = 0;
		for (Transaction t : transactions) {
			if (t.getTransactionType() == TransactionType.INTEREST) {
				interest += t.getAmount();
			}
		}
		return interest;
	}

	public double getAmount() {
		return amount;
	}

	public AccountType getAccountType() {
		return accountType;
	}
	public InterestCalculator getInterestCalculator()
	{
		return interestCalculator;
	}
	
	// Reason for returning unmodifiable list is to avoid the reference of the list to be leaked
	public List<Transaction> getTransactions() {
		return Collections.unmodifiableList( transactions);
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public String getCustomerName() { return customerName; } 
	
	// Below method is added only for testing
	// please don't use below constructor for prod code
	// Below method are added only for testing
	// please don't use them in code
	// I could have made the constructor private and use reflection
	// but keeping time in mind limiting it here .
	public Account(AccountType accountType, List<Transaction> transactions,
			InterestCalculator interestCalculator, double amount) {
		this.accountType = accountType;
		this.transactions = transactions;
		interestCalculator = InterestCalculatorFactory.getInterestCalculator(accountType);
		this.amount = amount;
	}
}
